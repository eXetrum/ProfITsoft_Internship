## Завдання Блоку 2: Spring Boot and REST API

Контекст

Використовуйте предметну область, обрану під час виконання Завдання 1.
Сутність 1 (основна для нас) - відноситься як many-to-one до Сутності 2.
В цьому завданні ви створюватиме новий проект, тому деякі атрибути чи їх типи можуть бути змінені, порівняно з тим як ви робили в першому завданні.

Завдання
Розробити Spring Boot сервіс, який зберігає в БД (Postgre) і надає доступ через REST API до даних Сутностей 1 і 2. Сервіс має реалізовувати наступні endpoints (замініть entity1 і entity2 на назви відповідних сутносей:


<table>
    <thead>
        <tr>
            <th>Endpoint</th>
            <th>Що робить</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <p>POST /api/entity1</p>
                <p>{...}</p>
            </td>      
            <td>Створює новий запис Сутності 1.
Валідувати обов’язкові поля, їх формат і т.і.
            </td>
        </tr>
<tr>
    <td><p>GET /api/entity1/{id}</p></td>
    <td><p>Повертає детальні дані запису Сутності 1.
Включаючи дані Сутності 2, на яку він посилається, наприклад
“entity2”: {“id”: 2, “name”: “MyValue”}
</p></td>
</tr>
<tr>
    <td><p>PUT /api/entity1/{id}
<pre>{...}</pre></p></td>
    <td><p>Оновлює дані одного запису Сутності 1 по ID.
Не забуваємо про валідацію.</p></td>
</tr>
<tr>
    <td><p>DELETE /api/entity1/{id}</p></td>
    <td><p>Видаляє запис Сутності 1 по ID</p></td>
</tr>
<tr>
    <td>
    <p>POST /api/entity1/_list</p>
<pre>
{
    “entity2Id”: 2,
    "..."
    “page”: 0,
    “size”: 20
}
</pre>
    </td>
    <td><p>Повертає структуру даних, яка має список елементів Сутності 1, які відповідають запитаній сторінці, а також загальну кількість сторінок. Наприклад:</p>
<pre>
{
    “list”: [...],
    “totalPages”: 5
}
</pre>
<p>
Записи в масиві матимуть скорочений набір полів Сутності 1 (бо не всі поля потрібні в режимі списку).
В запиті опціонально можна вказати поля (2-3 поля), по яким можна фільтрувати записи (entity2 та ін.).
Фільтрація має бути на рівні запросу до БД! Не забувайте про індекси!
</p>
</td>
</tr>
<tr>
    <td><p>POST /api/entity1/_report</p>
<pre>
{
    “entity2Id”: 2,
    …
}
</pre>
</td>
    <td>Працює схожим чином, як і _list, але генерує і пропонує завантажити файл-репорт з усіма записами, які відповідають критеріям фільтрації (не лише однієї сторінки).
Формат файлу: Excel або CSV (на ваш вибір).
Використовуйте правильні заголовки відповіді, щоб браузер пропонував зберегти файл з правильним ім’ям файлу.</td>
</tr>
<tr>
    <td><p>POST /api/entity1/upload</p></td>
    <td><p>Приймає JSON-файл, для яких розроблювався парсер в Завданні 1 (формат можна адаптувати). Зберігає в БД всі валідні записи з цього файлу. У відповідь генерує JSON, в якому зазначає кількість успішно імпортованих записів, а також неуспішно (наприклад, не знайшли відповідний запис Сутності 2).</p></td>
</tr>
<tr>
    <td><p>GET /api/entity2</p></td>
    <td><p>Повертає список всіх наявних в БД записів Сутності 2</p></td>
</tr>
<tr>
    <td><p>POST /api/entity2</p>
<pre>
{...}
</pre>
</td>
    <td><p>Додає запис Сутності 2
Мати контроль унікальності найменувань Сутності 2 (не дозволяти створювати дублікати)</p></td>
</tr>
<tr>
    <td><p>PUT /api/entity2/{id}</p>
<pre>
{...}
</pre>
</td>
    <td><p>Змінює запис Сутності 2 по ID.
Враховуючи контроль унікальності найменувань Сутності 2</p></td>
</tr>
<tr>
    <td><p>DELETE /api/entity2/{id}</p></td>
    <td><p>Видаляє запис Сутності 2 по ID</p></td>
</tr>
    </tbody>
</table>

<p>
Покрити інтеграційнимии тестами кожен endpoint.
Створити liquibase скрипт, який при запуску додатку створює необхідну схему БД, а також наповнення для Сутності 2.
Прикласти в репозиторії JSON-файл для імпорту даних (має бути узгодженим з liquibase скриптом наповнення).
</p>

## Збірка та запуск
1. ```console
   git clone
   ```
2. ```console
   cd Task2
   ```
3. ```console
   docker-compose -f .\docker-compose-postgres.yaml up -d
   ```
4. ```console
   mvn spring-boot:run
   ```
   
## Інтеграційні тести
```console
mvn test
```
